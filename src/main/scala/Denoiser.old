import scala.math.exp
import scala.util.Random
import Utils.Tensor

class Denoiser (imageMatrix :Array[Array[Int]]) {
    val ITA = 1
    val BETA = 1
    //var subMatrix :Array[Array[Int]] = Nil

    /*def denoiseImage(burnInSteps: Int, totalSamples: Int): Array[Array[Int]] = {
        //posterior = get_posterior(filename, burn_in_steps, total_samples, logfile=logfile)
        Tensor.where(subMatrix, el => el > 0, 255, 0)
    }*/

    def load_image(initX: Int, initY: Int, endX: Int, endY: Int): Array[Array[Int]] = {
        val out = imageMatrix.slice(initX, endX + 1)
                    .map( col => col.slice(initY, endY + 1))
        Tensor.where(out, el => el > 128, 1, -1)
    }

    def load_image : Array[Array[Int]] =
        Tensor.where(imageMatrix, el => el > 128, 1, -1)

    def getPosterior(burnInSteps: Int, totalSamples: Int): Array[Array[Int]] = {
        val X = load_image
        val shapeX = Tensor.shape(X)
        val posterior = Tensor.zeros(shapeX)
        val Y = Tensor.randomChoice(Array(1, -1), shapeX)
        var energy_list = List[String]()

        for { step <- 0 until burnInSteps + totalSamples} {
            for {
                i <- 1 to shapeX(0) -1
                j <- 1 to shapeX(1) -1
            } {
                val y = sampleY(i, j, Y, X)
                Y(i)(j) = y
                if y == 1 && step >= burnInSteps then posterior(i)(j) += 1
            }
//        energy = -np.sum(np.multiply(Y, X)) * ITA - (np.sum(np.multiply(Y[:-1], Y[1:])) + np.sum(np.multiply(Y[:, :-1], Y[:, 1:]))) * BETA

           /* val energy = - Tensor.sum( Tensor.multiply(Y, X)) * ITA 
                         - ( Tensor.sum(Tensor.multiply(Y.slice(), Y)) )
            * BETA
            if step < burnInSteps then 
                energy_list = (step + "\t" + energy + "\tB") :: energy_list
            else
                energy_list = (step + "\t" + energy + "\tS") :: energy_list*/
        }
        imageMatrix
    }

    def sampleY(i: Int, j: Int, Y: Array[Array[Int]], X: Array[Array[Int]]): Int = {
        val markovBlanket : Array[Int] = Array(
            Y(i - 1)(j), 
            Y(i)(j - 1), 
            Y(i)(j + 1),
            Y(i + 1)(j)
        )
        val w = ITA * X(i)(j) + BETA * Tensor.sum(markovBlanket)
        val prob = 1 / (1 + math.exp(-2*w))
        if Random.nextDouble < prob then 1 else -1
    }
}
